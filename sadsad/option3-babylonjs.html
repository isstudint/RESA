<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer - Babylon.js</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        
        #ui-panel {
            position: absolute;
            top: 0;
            left: 0;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 10;
            border-bottom-right-radius: 10px;
        }
        
        #ui-panel h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        
        .control-group {
            margin: 10px 0;
        }
        
        select, button {
            padding: 8px;
            margin: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 20;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div id="ui-panel">
        <h1>Babylon.js Model Viewer</h1>
        <div class="control-group">
            <select id="model-select">
                <option value="untitled.glb">Default Model (GLB)</option>
                <option value="house.fbx">House (FBX)</option>
            </select>
            <button id="load-model">Load Model</button>
        </div>
        <div class="control-group">
            <button id="toggle-wireframe">Toggle Wireframe</button>
            <button id="toggle-rotation">Toggle Auto-Rotation</button>
            <button id="toggle-environment">Toggle Environment</button>
        </div>
    </div>
    
    <div id="loading">Loading...</div>
    
    <!-- Babylon.js Libraries -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    
    <script>
        window.addEventListener('DOMContentLoaded', function() {
            // Get the canvas and UI elements
            const canvas = document.getElementById('renderCanvas');
            const loadingText = document.getElementById('loading');
            const modelSelect = document.getElementById('model-select');
            const loadModelButton = document.getElementById('load-model');
            const toggleWireframeButton = document.getElementById('toggle-wireframe');
            const toggleRotationButton = document.getElementById('toggle-rotation');
            const toggleEnvironmentButton = document.getElementById('toggle-environment');
            
            // Create the Babylon.js engine
            const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
            
            // Variables to keep track of the current state
            let currentModel = null;
            let autoRotate = true;
            let showEnvironment = true;
            let scene = null;
            
            // Create the scene
            function createScene() {
                // Create a new scene
                scene = new BABYLON.Scene(engine);
                
                // Create a camera
                const camera = new BABYLON.ArcRotateCamera(
                    "camera", 
                    -Math.PI / 2, 
                    Math.PI / 2.5, 
                    10, 
                    new BABYLON.Vector3(0, 0, 0),
                    scene
                );
                camera.attachControl(canvas, true);
                camera.wheelPrecision = 50;
                camera.lowerRadiusLimit = 2;
                camera.upperRadiusLimit = 20;
                
                // Create lighting
                const hemisphericLight = new BABYLON.HemisphericLight(
                    "hemisphericLight", 
                    new BABYLON.Vector3(0, 1, 0), 
                    scene
                );
                hemisphericLight.intensity = 0.7;
                
                const directionalLight = new BABYLON.DirectionalLight(
                    "directionalLight",
                    new BABYLON.Vector3(0.5, -1, 1),
                    scene
                );
                directionalLight.intensity = 0.7;
                directionalLight.position = new BABYLON.Vector3(0, 10, -10);
                
                // Create a ground plane
                const ground = BABYLON.MeshBuilder.CreateGround(
                    "ground",
                    { width: 20, height: 20 },
                    scene
                );
                ground.position.y = -2;
                const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
                groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                groundMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                ground.material = groundMaterial;
                ground.receiveShadows = true;
                
                // Create environment
                const envTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(
                    "https://assets.babylonjs.com/environments/environmentSpecular.env",
                    scene
                );
                scene.environmentTexture = envTexture;
                scene.createDefaultSkybox(envTexture, true, 1000, 0.1);
                
                // Load default model
                loadModel('untitled.glb');
                
                // Register a render loop to repeatedly render the scene
                engine.runRenderLoop(function () {
                    if (scene && autoRotate && currentModel) {
                        currentModel.rotate(BABYLON.Axis.Y, 0.005, BABYLON.Space.WORLD);
                    }
                    scene.render();
                });
                
                // Handle browser resize
                window.addEventListener('resize', function () {
                    engine.resize();
                });
                
                return scene;
            }
            
            // Function to load models
            function loadModel(modelUrl) {
                // Show loading text
                loadingText.style.display = 'block';
                
                // Remove previous model if exists
                if (currentModel) {
                    currentModel.dispose();
                    currentModel = null;
                }
                
                // Determine file extension
                const fileExtension = modelUrl.split('.').pop().toLowerCase();
                
                // Choose appropriate loader
                if (fileExtension === 'glb' || fileExtension === 'gltf') {
                    BABYLON.SceneLoader.ImportMesh(
                        "",
                        "./",
                        modelUrl,
                        scene,
                        function (meshes) {
                            processLoadedModel(meshes);
                        },
                        function (progressEvent) {
                            // Progress
                            if (progressEvent.lengthComputable) {
                                const percent = (progressEvent.loaded * 100 / progressEvent.total).toFixed();
                                loadingText.textContent = `Loading: ${percent}%`;
                            }
                        },
                        function (error) {
                            console.error("Error loading model:", error);
                            loadingText.style.display = 'none';
                        }
                    );
                } else if (fileExtension === 'fbx') {
                    BABYLON.SceneLoader.ImportMesh(
                        "",
                        "./",
                        modelUrl,
                        scene,
                        function (meshes) {
                            processLoadedModel(meshes);
                        }
                    );
                } else {
                    console.error("Unsupported file format:", fileExtension);
                    loadingText.style.display = 'none';
                }
            }
            
            // Process loaded model
            function processLoadedModel(meshes) {
                // Create a root mesh to contain all imported meshes
                currentModel = new BABYLON.Mesh("root", scene);
                
                // Parent all meshes to our root
                for (let mesh of meshes) {
                    if (mesh.parent === null) {
                        mesh.parent = currentModel;
                    }
                    
                    // Enable shadows
                    if (mesh.material) {
                        mesh.receiveShadows = true;
                    }
                }
                
                // Scale and center model
                const boundingInfo = getBoundingInfo(meshes);
                const size = boundingInfo.size;
                const center = boundingInfo.center;
                
                // Scale to reasonable size
                const maxDimension = Math.max(size.x, size.y, size.z);
                const scaleFactor = 5 / maxDimension;
                currentModel.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);
                
                // Center the model
                currentModel.position.x = -center.x * scaleFactor;
                currentModel.position.y = -center.y * scaleFactor;
                currentModel.position.z = -center.z * scaleFactor;
                
                // Hide loading text
                loadingText.style.display = 'none';
            }
            
            // Calculate bounding info for meshes
            function getBoundingInfo(meshes) {
                let min = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                let max = new BABYLON.Vector3(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
                
                for (let mesh of meshes) {
                    if (mesh.getBoundingInfo) {
                        const boundingInfo = mesh.getBoundingInfo();
                        const meshMin = boundingInfo.boundingBox.minimumWorld;
                        const meshMax = boundingInfo.boundingBox.maximumWorld;
                        
                        min = BABYLON.Vector3.Minimize(min, meshMin);
                        max = BABYLON.Vector3.Maximize(max, meshMax);
                    }
                }
                
                const size = max.subtract(min);
                const center = min.add(size.scale(0.5));
                
                return { size, center };
            }
            
            // Toggle wireframe mode
            function toggleWireframe() {
                if (!currentModel) return;
                
                const isWireframe = !scene.getMeshByName(currentModel.getChildren()[0].name).material.wireframe;
                
                for (let mesh of currentModel.getChildren()) {
                    if (mesh.material) {
                        mesh.material.wireframe = isWireframe;
                    }
                }
            }
            
            // Toggle auto-rotation
            function toggleRotation() {
                autoRotate = !autoRotate;
            }
            
            // Toggle environment visibility
            function toggleEnvironment() {
                showEnvironment = !showEnvironment;
                scene.environmentTexture.level = showEnvironment ? 1.0 : 0.0;
                
                // Toggle skybox visibility
                const skybox = scene.getMeshByName("BackgroundSkybox");
                if (skybox) {
                    skybox.visibility = showEnvironment ? 1.0 : 0.0;
                }
            }
            
            // Add event listeners to buttons
            loadModelButton.addEventListener('click', function() {
                loadModel(modelSelect.value);
            });
            
            toggleWireframeButton.addEventListener('click', toggleWireframe);
            toggleRotationButton.addEventListener('click', toggleRotation);
            toggleEnvironmentButton.addEventListener('click', toggleEnvironment);
            
            // Create the scene
            createScene();
        });
    </script>
</body>
</html>
