<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }
        
        #overlay h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        
        #controls {
            margin: 10px 0;
        }
        
        select, button {
            padding: 8px;
            margin: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 20;
        }
        
        #scene-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>Three.js 3D Model Viewer</h1>
        <div id="controls">
            <select id="model-select">
                <option value="./untitled.glb">Default Model (GLB)</option>
                <option value="./house.fbx">House (FBX)</option>
            </select>
            
            <button id="load-model">Load Model</button>
            <button id="toggle-rotation">Toggle Rotation</button>
            <button id="toggle-wireframe">Toggle Wireframe</button>
        </div>
    </div>
    
    <div id="loading">Loading 3D model...</div>
    
    <div id="scene-container"></div>
    
    <!-- Three.js library - using older, more compatible version (r132) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.js"></script>
    <!-- Environment map for realistic reflections -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/RGBELoader.js"></script>
    
    <!-- Add error handling for script loading -->
    <script>
        window.addEventListener('error', function(e) {
            console.error('Script error:', e);
            document.getElementById('loading').textContent = 'Error loading scripts: ' + e.message;
            document.getElementById('loading').style.display = 'block';
        }, true);
    </script>
    
    <script>
        // Main variables
        let scene, camera, renderer, controls;
        let currentModel = null;
        let isRotating = false;
        
        // Add a post-processing effect
        let composer;
        
        // Initialize Three.js scene with premium rendering features
        function init() {
            // Create scene with gradient background
            scene = new THREE.Scene();
            
            // Create a nice gradient background
            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 2;
            
            const context = canvas.getContext('2d');
            const gradient = context.createLinearGradient(0, 0, 0, 2);
            gradient.addColorStop(0, '#2c3e50'); // Dark blue at top
            gradient.addColorStop(1, '#1a1a1a'); // Near black at bottom
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 2, 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            scene.background = texture;
            
            // Create camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            camera.position.y = 2;
            
            // Create professional-grade renderer with photo-realistic settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Balance quality and performance
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
            
            // Use physically accurate lighting
            renderer.physicallyCorrectLights = true;
            
            // Color correction settings
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.gammaOutput = true;
            renderer.gammaFactor = 2.2; // Standard gamma correction
            
            // Use realistic HDR-like tone mapping
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinema-quality tone mapping
            renderer.toneMappingExposure = 1.2; // Slightly brighter exposure
            document.getElementById('scene-container').appendChild(renderer.domElement);
            
            // Premium studio-quality lighting setup
            // Ambient light for base illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Main key light (simulates sun or main studio light)
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(5, 10, 7.5);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048; // Higher resolution shadows
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.bias = -0.0001; // Fix shadow artifacts
            keyLight.shadow.radius = 2; // Softer shadow edges
            scene.add(keyLight);
            
            // Fill light (softens shadows from the key light)
            const fillLight = new THREE.DirectionalLight(0xffd6a9, 0.4); // Warm tint
            fillLight.position.set(-5, 0, -10);
            scene.add(fillLight);
            
            // Rim light (highlights edges of objects)
            const rimLight = new THREE.DirectionalLight(0xbae1ff, 0.5); // Cool blue tint
            rimLight.position.set(0, 5, -10);
            scene.add(rimLight);
            
            // Bottom fill light (subtle illumination from below)
            const bottomLight = new THREE.DirectionalLight(0xffffff, 0.2);
            bottomLight.position.set(0, -5, 0);
            scene.add(bottomLight);
            
            // Add stylish ground with reflections
            const groundSize = 100;
            
            // Create grid texture for the floor
            const gridCanvas = document.createElement('canvas');
            gridCanvas.width = 512;
            gridCanvas.height = 512;
            const gridContext = gridCanvas.getContext('2d');
            
            // Fill canvas with dark color
            gridContext.fillStyle = '#333';
            gridContext.fillRect(0, 0, 512, 512);
            
            // Draw grid lines
            gridContext.strokeStyle = '#555';
            gridContext.lineWidth = 1;
            const gridSpacing = 32;
            
            // Draw grid
            for (let i = 0; i <= gridCanvas.width; i += gridSpacing) {
                gridContext.beginPath();
                gridContext.moveTo(i, 0);
                gridContext.lineTo(i, gridCanvas.height);
                gridContext.stroke();
                
                gridContext.beginPath();
                gridContext.moveTo(0, i);
                gridContext.lineTo(gridCanvas.width, i);
                gridContext.stroke();
            }
            
            // Create texture from canvas
            const groundTexture = new THREE.CanvasTexture(gridCanvas);
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(groundSize/5, groundSize/5);
            
            // Create ground material with slight reflection
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: groundTexture,
                color: 0x555555,
                roughness: 0.6,
                metalness: 0.3,
                envMapIntensity: 0.5
            });
            
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(groundSize, groundSize),
                groundMaterial
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add controls with error handling
            try {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            } catch (e) {
                console.error("Error creating controls:", e);
                document.getElementById('loading').textContent = "Error with controls: " + e.message;
                document.getElementById('loading').style.display = 'block';
            }
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('load-model').addEventListener('click', loadSelectedModel);
            document.getElementById('toggle-rotation').addEventListener('click', toggleRotation);
            document.getElementById('toggle-wireframe').addEventListener('click', toggleWireframe);
            
            // Load initial model with absolute path to ensure it's found
            loadModel('./untitled.glb');
            
            // Create simple post-processing for better visuals
            try {
                // Add a subtle vignette effect (darkened edges)
                const vignetteEffect = {
                    uniforms: {
                        tDiffuse: { value: null },
                        offset: { value: 1.0 },
                        darkness: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tDiffuse;
                        uniform float offset;
                        uniform float darkness;
                        varying vec2 vUv;
                        void main() {
                            // Centered coordinate
                            vec2 uv = (vUv - 0.5) * 2.0;
                            
                            // Subtle vignette
                            float vignetteAmount = smoothstep(0.8, offset * 1.4, abs(dot(uv, uv)));
                            vec4 color = texture2D(tDiffuse, vUv);
                            gl_FragColor = vec4(mix(color.rgb, color.rgb * (1.0 - vignetteAmount * darkness), 0.5), color.a);
                        }
                    `
                };
                
                // Add subtle screen-space ambient occlusion
                const ssaoEffect = {
                    uniforms: {
                        tDiffuse: { value: null }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tDiffuse;
                        varying vec2 vUv;
                        void main() {
                            vec4 color = texture2D(tDiffuse, vUv);
                            // Simple color grading - slightly increase contrast
                            color.rgb = pow(color.rgb, vec3(1.05));
                            gl_FragColor = color;
                        }
                    `
                };
            } catch (e) {
                console.warn("Post-processing setup failed:", e);
            }
            
            // Animation loop
            animate();
        }
        
        function loadSelectedModel() {
            const modelSelect = document.getElementById('model-select');
            const modelUrl = modelSelect.value;
            loadModel(modelUrl);
        }
        
        function loadModel(modelUrl) {
            // Show loading indicator with filename
            const loadingElement = document.getElementById('loading');
            loadingElement.textContent = `Loading model: ${modelUrl}...`;
            loadingElement.style.display = 'block';
            
            console.log('Attempting to load model:', modelUrl);
            
            // Remove previous model
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            
            // Determine loader based on file extension
            const fileExtension = modelUrl.split('.').pop().toLowerCase();
            
            if (fileExtension === 'glb' || fileExtension === 'gltf') {
                const loader = new THREE.GLTFLoader();
                loader.load(
                    modelUrl,
                    function(gltf) {
                        processModel(gltf.scene);
                    },
                    onProgress,
                    onError
                );
            } else if (fileExtension === 'fbx') {
                // Make sure the FBX loader is fully initialized with fflate
                if (!window.fflate && window.THREE && THREE.FBXLoader) {
                    console.warn('FBX Loader might need fflate for decompression');
                }
                const loader = new THREE.FBXLoader();
                loader.load(
                    modelUrl,
                    function(object) {
                        processModel(object);
                    },
                    onProgress,
                    onError
                );
            } else if (fileExtension === 'obj') {
                const loader = new THREE.OBJLoader();
                loader.load(
                    modelUrl,
                    function(object) {
                        processModel(object);
                    },
                    onProgress,
                    onError
                );
            } else {
                console.error('Unsupported file format:', fileExtension);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        function processModel(model) {
            // Configure model with premium materials
            model.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Create pseudo-environment map for reflections
                    if (!window.envMap) {
                        // Create a simple environment map for reflections
                        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
                        cubeRenderTarget.texture.type = THREE.HalfFloatType;
                        window.envMap = cubeRenderTarget.texture;
                    }
                    
                    // Apply high-quality material settings
                    if (child.material) {
                        // Handle materials as arrays or single materials
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        
                        for (let i = 0; i < materials.length; i++) {
                            let mat = materials[i];
                            
                            // For basic materials, convert to standard material
                            if (mat.isMeshBasicMaterial || !mat.isMeshStandardMaterial) {
                                const oldMap = mat.map;
                                const oldColor = mat.color ? mat.color.clone() : new THREE.Color(0xffffff);
                                
                                mat = new THREE.MeshPhysicalMaterial({
                                    map: oldMap,
                                    color: oldColor,
                                    metalness: 0.1,
                                    roughness: 0.8,
                                    envMap: window.envMap,
                                    envMapIntensity: 0.5,
                                    clearcoat: 0.1,
                                    clearcoatRoughness: 0.3,
                                    side: THREE.DoubleSide
                                });
                                
                                if (Array.isArray(child.material)) {
                                    child.material[i] = mat;
                                } else {
                                    child.material = mat;
                                }
                            } 
                            // Enhance standard materials
                            else {
                                mat.envMap = window.envMap;
                                mat.envMapIntensity = 0.5;
                                mat.side = THREE.DoubleSide;
                                mat.flatShading = false;
                                mat.roughness = Math.min(mat.roughness || 0.8, 0.8); // Ensure not too rough
                                mat.metalness = Math.min(mat.metalness || 0.1, 0.5); // Add subtle metalness
                                
                                // Add subtle clearcoat if this is a physical material
                                if (mat.isMeshPhysicalMaterial) {
                                    mat.clearcoat = 0.1;
                                    mat.clearcoatRoughness = 0.3;
                                }
                            }
                            
                            mat.needsUpdate = true;
                        }
                    }
                }
            });
            
            // Center and scale model
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 4 / maxDim;
            model.scale.multiplyScalar(scale);
            
            model.position.x = -center.x * scale;
            model.position.y = -center.y * scale;
            model.position.z = -center.z * scale;
            
            // Add model to scene
            scene.add(model);
            currentModel = model;
            
            // Hide loading indicator
            document.getElementById('loading').style.display = 'none';
        }
        
        function onProgress(xhr) {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            console.log(percentComplete.toFixed(2) + '% loaded');
        }
        
        function onError(error) {
            console.error('An error happened:', error);
            const loadingElement = document.getElementById('loading');
            loadingElement.textContent = `Error loading model: ${error.message || 'Unknown error'}`;
            loadingElement.style.display = 'block';
            
            // Create a simple cube as a fallback model
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
            currentModel = cube;
            
            // Display error for 3 seconds then hide
            setTimeout(() => {
                loadingElement.style.display = 'none';
            }, 3000);
        }
        
        function toggleRotation() {
            isRotating = !isRotating;
        }
        
        function toggleWireframe() {
            if (!currentModel) return;
            
            // Track if we're enabling or disabling wireframe
            let isEnablingWireframe = false;
            
            // Check the first mesh to determine what we're doing
            currentModel.traverse(function(child) {
                if (child.isMesh && child.material) {
                    isEnablingWireframe = !child.material.wireframe;
                    return false; // Stop after checking the first mesh
                }
            });
            
            // Apply the change to all meshes
            currentModel.traverse(function(child) {
                if (child.isMesh && child.material) {
                    // Toggle wireframe state
                    child.material.wireframe = isEnablingWireframe;
                    
                    // If disabling wireframe, make sure we restore smooth shading
                    if (!isEnablingWireframe) {
                        child.material.flatShading = false;
                        child.material.needsUpdate = true;
                    }
                }
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update composer if it exists
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Rotate model if enabled
            if (isRotating && currentModel) {
                currentModel.rotation.y += 0.005; // Slower, more elegant rotation
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
